
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';

export import DMMF = runtime.DMMF

/**
 * Prisma Errors
 */
export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
export import PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export import sql = runtime.sqltag
export import empty = runtime.empty
export import join = runtime.join
export import raw = runtime.raw
export import Sql = runtime.Sql

/**
 * Decimal.js
 */
export import Decimal = runtime.Decimal

/**
 * Prisma Client JS version: 2.13.1
 * Query Engine version: fcbc4bb2d306c86c28014f596b1e8c7980af8bd4
 */
export type PrismaVersion = {
  client: string
}

export const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export type InputJsonObject = {[Key in string]?: JsonValue}
 
export interface InputJsonArray extends Array<JsonValue> {}
 
export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
 type SelectAndInclude = {
  select: any
  include: any
}
type HasSelect = {
  select: any
}
type HasInclude = {
  include: any
}
type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;



/**
 * Used by group by
 */
export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>

/**
 * Like `Pick`, but with an array
 */
type PickArray<T, K extends Array<keyof T>> = Pick<T, TupleToUnion<K>>





/**
 * Model Customer
 */

export type Customer = {
  idCustomer: number
  first_name: string
  last_name: string
  email: string
  password: string
}

/**
 * Model Table
 */

export type Table = {
  idTable: number
  capacity: number
  avalible: boolean
  resutaurantId: number
}

/**
 * Model Restaurant
 */

export type Restaurant = {
  idRestaurant: number
  name: string
  location: string
  description: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate;

  /**
   * `prisma.restaurant`: Exposes CRUD operations for the **Restaurant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurants
    * const restaurants = await prisma.restaurant.findMany()
    * ```
    */
  get restaurant(): Prisma.RestaurantDelegate;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.13.1
   * Query Engine version: fcbc4bb2d306c86c28014f596b1e8c7980af8bd4
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;



  /**
   * Used by group by
   */
  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Customer: 'Customer',
    Table: 'Table',
    Restaurant: 'Restaurant'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    count: number | null
    avg: CustomerAvgAggregateOutputType | null
    sum: CustomerSumAggregateOutputType | null
    min: CustomerMinAggregateOutputType | null
    max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    idCustomer: number
  }

  export type CustomerSumAggregateOutputType = {
    idCustomer: number
  }

  export type CustomerMinAggregateOutputType = {
    idCustomer: number
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    idCustomer: number
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
  }

  export type CustomerCountAggregateOutputType = {
    idCustomer: number
    first_name: number | null
    last_name: number | null
    email: number | null
    password: number | null
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    idCustomer?: true
  }

  export type CustomerSumAggregateInputType = {
    idCustomer?: true
  }

  export type CustomerMinAggregateInputType = {
    idCustomer?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
  }

  export type CustomerMaxAggregateInputType = {
    idCustomer?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
  }

  export type CustomerCountAggregateInputType = {
    idCustomer?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    _all?: true
  }

  export type AggregateCustomerArgs = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByInput>
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: CustomerAvgAggregateInputType
    sum?: CustomerSumAggregateInputType
    min?: CustomerMinAggregateInputType
    max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends AggregateCustomerArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetCustomerAggregateScalarType<T[P]>
  }

  export type GetCustomerAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof CustomerAvgAggregateOutputType ? CustomerAvgAggregateOutputType[P] : never
  }

    



  export type CustomerSelect = {
    idCustomer?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
  }

  export type CustomerGetPayload<
    S extends boolean | null | undefined | CustomerArgs,
    U = keyof S
      > = S extends true
        ? Customer
    : S extends undefined
    ? never
    : S extends CustomerArgs | FindManyCustomerArgs
    ?'include' extends U
    ? Customer 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Customer ?Customer [P]
  : 
     never
  } 
    : Customer
  : Customer


  export interface CustomerDelegate {
    /**
     * Find zero or one Customer that matches the filter.
     * @param {FindUniqueCustomerArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueCustomerArgs>(
      args: Subset<T, FindUniqueCustomerArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer | null>, Prisma__CustomerClient<CustomerGetPayload<T> | null>>
    /**
     * Find the first Customer that matches the filter.
     * @param {FindFirstCustomerArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstCustomerArgs>(
      args?: Subset<T, FindFirstCustomerArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer | null>, Prisma__CustomerClient<CustomerGetPayload<T> | null>>
    /**
     * Find zero or more Customers that matches the filter.
     * @param {FindManyCustomerArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `idCustomer`
     * const customerWithIdCustomerOnly = await prisma.customer.findMany({ select: { idCustomer: true } })
     * 
    **/
    findMany<T extends FindManyCustomerArgs>(
      args?: Subset<T, FindManyCustomerArgs>
    ): CheckSelect<T, Promise<Array<Customer>>, Promise<Array<CustomerGetPayload<T>>>>
    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs>(
      args: Subset<T, CustomerCreateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>
    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs>(
      args: Subset<T, CustomerDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>
    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs>(
      args: Subset<T, CustomerUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>
    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: Subset<T, CustomerDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Customers.
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs>(
      args: Subset<T, CustomerUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs>(
      args: Subset<T, CustomerUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>
    /**
     * Find zero or one Customer that matches the filter.
     * @param {FindUniqueCustomerArgs} args - Arguments to find a Customer
     * @deprecated This will be deprecated please use prisma.customer.findUnique
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueCustomerArgs>(
      args: Subset<T, FindUniqueCustomerArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer | null>, Prisma__CustomerClient<CustomerGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyCustomerArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateCustomerArgs>(args: Subset<T, AggregateCustomerArgs>): Promise<GetCustomerAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Customer findUnique
   */
  export type FindUniqueCustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
    **/
    select?: CustomerSelect | null
    /**
     * Filter, which Customer to fetch.
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer findFirst
   */
  export type FindFirstCustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
    **/
    select?: CustomerSelect | null
    /**
     * Filter, which Customer to fetch.
    **/
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByInput>
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer findMany
   */
  export type FindManyCustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
    **/
    select?: CustomerSelect | null
    /**
     * Filter, which Customers to fetch.
    **/
    where?: CustomerWhereInput
    /**
     * Determine the order of the Customers to fetch.
    **/
    orderBy?: Enumerable<CustomerOrderByInput>
    /**
     * Sets the position for listing Customers.
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * The number of Customers to fetch. If negative number, it will take Customers before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Customers.
    **/
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Customer
    **/
    select?: CustomerSelect | null
    /**
     * The data needed to create a Customer.
    **/
    data: CustomerCreateInput
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customer
    **/
    select?: CustomerSelect | null
    /**
     * The data needed to update a Customer.
    **/
    data: CustomerUpdateInput
    /**
     * Choose, which Customer to update.
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs = {
    data: CustomerUpdateManyMutationInput
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customer
    **/
    select?: CustomerSelect | null
    /**
     * The filter to search for the Customer to update in case it exists.
    **/
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
    **/
    create: CustomerCreateInput
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
    **/
    update: CustomerUpdateInput
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customer
    **/
    select?: CustomerSelect | null
    /**
     * Filter which Customer to delete.
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs = {
    where?: CustomerWhereInput
  }


  /**
   * Customer without action
   */
  export type CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
    **/
    select?: CustomerSelect | null
  }



  /**
   * Model Table
   */


  export type AggregateTable = {
    count: number | null
    avg: TableAvgAggregateOutputType | null
    sum: TableSumAggregateOutputType | null
    min: TableMinAggregateOutputType | null
    max: TableMaxAggregateOutputType | null
  }

  export type TableAvgAggregateOutputType = {
    idTable: number
    capacity: number
    resutaurantId: number
  }

  export type TableSumAggregateOutputType = {
    idTable: number
    capacity: number
    resutaurantId: number
  }

  export type TableMinAggregateOutputType = {
    idTable: number
    capacity: number
    avalible: boolean | null
    resutaurantId: number
  }

  export type TableMaxAggregateOutputType = {
    idTable: number
    capacity: number
    avalible: boolean | null
    resutaurantId: number
  }

  export type TableCountAggregateOutputType = {
    idTable: number
    capacity: number
    avalible: number | null
    resutaurantId: number
    _all: number
  }


  export type TableAvgAggregateInputType = {
    idTable?: true
    capacity?: true
    resutaurantId?: true
  }

  export type TableSumAggregateInputType = {
    idTable?: true
    capacity?: true
    resutaurantId?: true
  }

  export type TableMinAggregateInputType = {
    idTable?: true
    capacity?: true
    avalible?: true
    resutaurantId?: true
  }

  export type TableMaxAggregateInputType = {
    idTable?: true
    capacity?: true
    avalible?: true
    resutaurantId?: true
  }

  export type TableCountAggregateInputType = {
    idTable?: true
    capacity?: true
    avalible?: true
    resutaurantId?: true
    _all?: true
  }

  export type AggregateTableArgs = {
    where?: TableWhereInput
    orderBy?: Enumerable<TableOrderByInput>
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: TableAvgAggregateInputType
    sum?: TableSumAggregateInputType
    min?: TableMinAggregateInputType
    max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends AggregateTableArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetTableAggregateScalarType<T[P]>
  }

  export type GetTableAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof TableAvgAggregateOutputType ? TableAvgAggregateOutputType[P] : never
  }

    



  export type TableSelect = {
    idTable?: boolean
    capacity?: boolean
    avalible?: boolean
    restaurant?: boolean | RestaurantArgs
    resutaurantId?: boolean
  }

  export type TableInclude = {
    restaurant?: boolean | RestaurantArgs
  }

  export type TableGetPayload<
    S extends boolean | null | undefined | TableArgs,
    U = keyof S
      > = S extends true
        ? Table
    : S extends undefined
    ? never
    : S extends TableArgs | FindManyTableArgs
    ?'include' extends U
    ? Table  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'restaurant'
        ? RestaurantGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Table ?Table [P]
  : 
          P extends 'restaurant'
        ? RestaurantGetPayload<S['select'][P]> : never
  } 
    : Table
  : Table


  export interface TableDelegate {
    /**
     * Find zero or one Table that matches the filter.
     * @param {FindUniqueTableArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueTableArgs>(
      args: Subset<T, FindUniqueTableArgs>
    ): CheckSelect<T, Prisma__TableClient<Table | null>, Prisma__TableClient<TableGetPayload<T> | null>>
    /**
     * Find the first Table that matches the filter.
     * @param {FindFirstTableArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstTableArgs>(
      args?: Subset<T, FindFirstTableArgs>
    ): CheckSelect<T, Prisma__TableClient<Table | null>, Prisma__TableClient<TableGetPayload<T> | null>>
    /**
     * Find zero or more Tables that matches the filter.
     * @param {FindManyTableArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `idTable`
     * const tableWithIdTableOnly = await prisma.table.findMany({ select: { idTable: true } })
     * 
    **/
    findMany<T extends FindManyTableArgs>(
      args?: Subset<T, FindManyTableArgs>
    ): CheckSelect<T, Promise<Array<Table>>, Promise<Array<TableGetPayload<T>>>>
    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
    **/
    create<T extends TableCreateArgs>(
      args: Subset<T, TableCreateArgs>
    ): CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>>
    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
    **/
    delete<T extends TableDeleteArgs>(
      args: Subset<T, TableDeleteArgs>
    ): CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>>
    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TableUpdateArgs>(
      args: Subset<T, TableUpdateArgs>
    ): CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>>
    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TableDeleteManyArgs>(
      args?: Subset<T, TableDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Tables.
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TableUpdateManyArgs>(
      args: Subset<T, TableUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
    **/
    upsert<T extends TableUpsertArgs>(
      args: Subset<T, TableUpsertArgs>
    ): CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>>
    /**
     * Find zero or one Table that matches the filter.
     * @param {FindUniqueTableArgs} args - Arguments to find a Table
     * @deprecated This will be deprecated please use prisma.table.findUnique
     * @example
     * // Get one Table
     * const table = await prisma.table.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueTableArgs>(
      args: Subset<T, FindUniqueTableArgs>
    ): CheckSelect<T, Prisma__TableClient<Table | null>, Prisma__TableClient<TableGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyTableArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateTableArgs>(args: Subset<T, AggregateTableArgs>): Promise<GetTableAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TableClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    restaurant<T extends RestaurantArgs = {}>(args?: Subset<T, RestaurantArgs>): CheckSelect<T, Prisma__RestaurantClient<Restaurant | null>, Prisma__RestaurantClient<RestaurantGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Table findUnique
   */
  export type FindUniqueTableArgs = {
    /**
     * Select specific fields to fetch from the Table
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TableInclude | null
    /**
     * Filter, which Table to fetch.
    **/
    where: TableWhereUniqueInput
  }


  /**
   * Table findFirst
   */
  export type FindFirstTableArgs = {
    /**
     * Select specific fields to fetch from the Table
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TableInclude | null
    /**
     * Filter, which Table to fetch.
    **/
    where?: TableWhereInput
    orderBy?: Enumerable<TableOrderByInput>
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TableScalarFieldEnum>
  }


  /**
   * Table findMany
   */
  export type FindManyTableArgs = {
    /**
     * Select specific fields to fetch from the Table
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TableInclude | null
    /**
     * Filter, which Tables to fetch.
    **/
    where?: TableWhereInput
    /**
     * Determine the order of the Tables to fetch.
    **/
    orderBy?: Enumerable<TableOrderByInput>
    /**
     * Sets the position for listing Tables.
    **/
    cursor?: TableWhereUniqueInput
    /**
     * The number of Tables to fetch. If negative number, it will take Tables before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Tables.
    **/
    skip?: number
    distinct?: Enumerable<TableScalarFieldEnum>
  }


  /**
   * Table create
   */
  export type TableCreateArgs = {
    /**
     * Select specific fields to fetch from the Table
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TableInclude | null
    /**
     * The data needed to create a Table.
    **/
    data: TableCreateInput
  }


  /**
   * Table update
   */
  export type TableUpdateArgs = {
    /**
     * Select specific fields to fetch from the Table
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TableInclude | null
    /**
     * The data needed to update a Table.
    **/
    data: TableUpdateInput
    /**
     * Choose, which Table to update.
    **/
    where: TableWhereUniqueInput
  }


  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs = {
    data: TableUpdateManyMutationInput
    where?: TableWhereInput
  }


  /**
   * Table upsert
   */
  export type TableUpsertArgs = {
    /**
     * Select specific fields to fetch from the Table
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TableInclude | null
    /**
     * The filter to search for the Table to update in case it exists.
    **/
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
    **/
    create: TableCreateInput
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
    **/
    update: TableUpdateInput
  }


  /**
   * Table delete
   */
  export type TableDeleteArgs = {
    /**
     * Select specific fields to fetch from the Table
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TableInclude | null
    /**
     * Filter which Table to delete.
    **/
    where: TableWhereUniqueInput
  }


  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs = {
    where?: TableWhereInput
  }


  /**
   * Table without action
   */
  export type TableArgs = {
    /**
     * Select specific fields to fetch from the Table
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TableInclude | null
  }



  /**
   * Model Restaurant
   */


  export type AggregateRestaurant = {
    count: number | null
    avg: RestaurantAvgAggregateOutputType | null
    sum: RestaurantSumAggregateOutputType | null
    min: RestaurantMinAggregateOutputType | null
    max: RestaurantMaxAggregateOutputType | null
  }

  export type RestaurantAvgAggregateOutputType = {
    idRestaurant: number
  }

  export type RestaurantSumAggregateOutputType = {
    idRestaurant: number
  }

  export type RestaurantMinAggregateOutputType = {
    idRestaurant: number
    name: string | null
    location: string | null
    description: string | null
  }

  export type RestaurantMaxAggregateOutputType = {
    idRestaurant: number
    name: string | null
    location: string | null
    description: string | null
  }

  export type RestaurantCountAggregateOutputType = {
    idRestaurant: number
    name: number | null
    location: number | null
    description: number | null
    _all: number
  }


  export type RestaurantAvgAggregateInputType = {
    idRestaurant?: true
  }

  export type RestaurantSumAggregateInputType = {
    idRestaurant?: true
  }

  export type RestaurantMinAggregateInputType = {
    idRestaurant?: true
    name?: true
    location?: true
    description?: true
  }

  export type RestaurantMaxAggregateInputType = {
    idRestaurant?: true
    name?: true
    location?: true
    description?: true
  }

  export type RestaurantCountAggregateInputType = {
    idRestaurant?: true
    name?: true
    location?: true
    description?: true
    _all?: true
  }

  export type AggregateRestaurantArgs = {
    where?: RestaurantWhereInput
    orderBy?: Enumerable<RestaurantOrderByInput>
    cursor?: RestaurantWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: RestaurantAvgAggregateInputType
    sum?: RestaurantSumAggregateInputType
    min?: RestaurantMinAggregateInputType
    max?: RestaurantMaxAggregateInputType
  }

  export type GetRestaurantAggregateType<T extends AggregateRestaurantArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetRestaurantAggregateScalarType<T[P]>
  }

  export type GetRestaurantAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof RestaurantAvgAggregateOutputType ? RestaurantAvgAggregateOutputType[P] : never
  }

    



  export type RestaurantSelect = {
    idRestaurant?: boolean
    name?: boolean
    location?: boolean
    description?: boolean
    tables?: boolean | FindManyTableArgs
  }

  export type RestaurantInclude = {
    tables?: boolean | FindManyTableArgs
  }

  export type RestaurantGetPayload<
    S extends boolean | null | undefined | RestaurantArgs,
    U = keyof S
      > = S extends true
        ? Restaurant
    : S extends undefined
    ? never
    : S extends RestaurantArgs | FindManyRestaurantArgs
    ?'include' extends U
    ? Restaurant  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tables'
        ? Array < TableGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Restaurant ?Restaurant [P]
  : 
          P extends 'tables'
        ? Array < TableGetPayload<S['select'][P]>>  : never
  } 
    : Restaurant
  : Restaurant


  export interface RestaurantDelegate {
    /**
     * Find zero or one Restaurant that matches the filter.
     * @param {FindUniqueRestaurantArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueRestaurantArgs>(
      args: Subset<T, FindUniqueRestaurantArgs>
    ): CheckSelect<T, Prisma__RestaurantClient<Restaurant | null>, Prisma__RestaurantClient<RestaurantGetPayload<T> | null>>
    /**
     * Find the first Restaurant that matches the filter.
     * @param {FindFirstRestaurantArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstRestaurantArgs>(
      args?: Subset<T, FindFirstRestaurantArgs>
    ): CheckSelect<T, Prisma__RestaurantClient<Restaurant | null>, Prisma__RestaurantClient<RestaurantGetPayload<T> | null>>
    /**
     * Find zero or more Restaurants that matches the filter.
     * @param {FindManyRestaurantArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restaurants
     * const restaurants = await prisma.restaurant.findMany()
     * 
     * // Get first 10 Restaurants
     * const restaurants = await prisma.restaurant.findMany({ take: 10 })
     * 
     * // Only select the `idRestaurant`
     * const restaurantWithIdRestaurantOnly = await prisma.restaurant.findMany({ select: { idRestaurant: true } })
     * 
    **/
    findMany<T extends FindManyRestaurantArgs>(
      args?: Subset<T, FindManyRestaurantArgs>
    ): CheckSelect<T, Promise<Array<Restaurant>>, Promise<Array<RestaurantGetPayload<T>>>>
    /**
     * Create a Restaurant.
     * @param {RestaurantCreateArgs} args - Arguments to create a Restaurant.
     * @example
     * // Create one Restaurant
     * const Restaurant = await prisma.restaurant.create({
     *   data: {
     *     // ... data to create a Restaurant
     *   }
     * })
     * 
    **/
    create<T extends RestaurantCreateArgs>(
      args: Subset<T, RestaurantCreateArgs>
    ): CheckSelect<T, Prisma__RestaurantClient<Restaurant>, Prisma__RestaurantClient<RestaurantGetPayload<T>>>
    /**
     * Delete a Restaurant.
     * @param {RestaurantDeleteArgs} args - Arguments to delete one Restaurant.
     * @example
     * // Delete one Restaurant
     * const Restaurant = await prisma.restaurant.delete({
     *   where: {
     *     // ... filter to delete one Restaurant
     *   }
     * })
     * 
    **/
    delete<T extends RestaurantDeleteArgs>(
      args: Subset<T, RestaurantDeleteArgs>
    ): CheckSelect<T, Prisma__RestaurantClient<Restaurant>, Prisma__RestaurantClient<RestaurantGetPayload<T>>>
    /**
     * Update one Restaurant.
     * @param {RestaurantUpdateArgs} args - Arguments to update one Restaurant.
     * @example
     * // Update one Restaurant
     * const restaurant = await prisma.restaurant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RestaurantUpdateArgs>(
      args: Subset<T, RestaurantUpdateArgs>
    ): CheckSelect<T, Prisma__RestaurantClient<Restaurant>, Prisma__RestaurantClient<RestaurantGetPayload<T>>>
    /**
     * Delete zero or more Restaurants.
     * @param {RestaurantDeleteManyArgs} args - Arguments to filter Restaurants to delete.
     * @example
     * // Delete a few Restaurants
     * const { count } = await prisma.restaurant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RestaurantDeleteManyArgs>(
      args?: Subset<T, RestaurantDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Restaurants.
     * @param {RestaurantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restaurants
     * const restaurant = await prisma.restaurant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RestaurantUpdateManyArgs>(
      args: Subset<T, RestaurantUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Restaurant.
     * @param {RestaurantUpsertArgs} args - Arguments to update or create a Restaurant.
     * @example
     * // Update or create a Restaurant
     * const restaurant = await prisma.restaurant.upsert({
     *   create: {
     *     // ... data to create a Restaurant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restaurant we want to update
     *   }
     * })
    **/
    upsert<T extends RestaurantUpsertArgs>(
      args: Subset<T, RestaurantUpsertArgs>
    ): CheckSelect<T, Prisma__RestaurantClient<Restaurant>, Prisma__RestaurantClient<RestaurantGetPayload<T>>>
    /**
     * Find zero or one Restaurant that matches the filter.
     * @param {FindUniqueRestaurantArgs} args - Arguments to find a Restaurant
     * @deprecated This will be deprecated please use prisma.restaurant.findUnique
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueRestaurantArgs>(
      args: Subset<T, FindUniqueRestaurantArgs>
    ): CheckSelect<T, Prisma__RestaurantClient<Restaurant | null>, Prisma__RestaurantClient<RestaurantGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyRestaurantArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateRestaurantArgs>(args: Subset<T, AggregateRestaurantArgs>): Promise<GetRestaurantAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Restaurant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RestaurantClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tables<T extends FindManyTableArgs = {}>(args?: Subset<T, FindManyTableArgs>): CheckSelect<T, Promise<Array<Table>>, Promise<Array<TableGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Restaurant findUnique
   */
  export type FindUniqueRestaurantArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
    **/
    select?: RestaurantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RestaurantInclude | null
    /**
     * Filter, which Restaurant to fetch.
    **/
    where: RestaurantWhereUniqueInput
  }


  /**
   * Restaurant findFirst
   */
  export type FindFirstRestaurantArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
    **/
    select?: RestaurantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RestaurantInclude | null
    /**
     * Filter, which Restaurant to fetch.
    **/
    where?: RestaurantWhereInput
    orderBy?: Enumerable<RestaurantOrderByInput>
    cursor?: RestaurantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RestaurantScalarFieldEnum>
  }


  /**
   * Restaurant findMany
   */
  export type FindManyRestaurantArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
    **/
    select?: RestaurantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RestaurantInclude | null
    /**
     * Filter, which Restaurants to fetch.
    **/
    where?: RestaurantWhereInput
    /**
     * Determine the order of the Restaurants to fetch.
    **/
    orderBy?: Enumerable<RestaurantOrderByInput>
    /**
     * Sets the position for listing Restaurants.
    **/
    cursor?: RestaurantWhereUniqueInput
    /**
     * The number of Restaurants to fetch. If negative number, it will take Restaurants before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` Restaurants.
    **/
    skip?: number
    distinct?: Enumerable<RestaurantScalarFieldEnum>
  }


  /**
   * Restaurant create
   */
  export type RestaurantCreateArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
    **/
    select?: RestaurantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RestaurantInclude | null
    /**
     * The data needed to create a Restaurant.
    **/
    data: RestaurantCreateInput
  }


  /**
   * Restaurant update
   */
  export type RestaurantUpdateArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
    **/
    select?: RestaurantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RestaurantInclude | null
    /**
     * The data needed to update a Restaurant.
    **/
    data: RestaurantUpdateInput
    /**
     * Choose, which Restaurant to update.
    **/
    where: RestaurantWhereUniqueInput
  }


  /**
   * Restaurant updateMany
   */
  export type RestaurantUpdateManyArgs = {
    data: RestaurantUpdateManyMutationInput
    where?: RestaurantWhereInput
  }


  /**
   * Restaurant upsert
   */
  export type RestaurantUpsertArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
    **/
    select?: RestaurantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RestaurantInclude | null
    /**
     * The filter to search for the Restaurant to update in case it exists.
    **/
    where: RestaurantWhereUniqueInput
    /**
     * In case the Restaurant found by the `where` argument doesn't exist, create a new Restaurant with this data.
    **/
    create: RestaurantCreateInput
    /**
     * In case the Restaurant was found with the provided `where` argument, update it with this data.
    **/
    update: RestaurantUpdateInput
  }


  /**
   * Restaurant delete
   */
  export type RestaurantDeleteArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
    **/
    select?: RestaurantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RestaurantInclude | null
    /**
     * Filter which Restaurant to delete.
    **/
    where: RestaurantWhereUniqueInput
  }


  /**
   * Restaurant deleteMany
   */
  export type RestaurantDeleteManyArgs = {
    where?: RestaurantWhereInput
  }


  /**
   * Restaurant without action
   */
  export type RestaurantArgs = {
    /**
     * Select specific fields to fetch from the Restaurant
    **/
    select?: RestaurantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RestaurantInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CustomerScalarFieldEnum: {
    idCustomer: 'idCustomer',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const TableScalarFieldEnum: {
    idTable: 'idTable',
    capacity: 'capacity',
    avalible: 'avalible',
    resutaurantId: 'resutaurantId'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const RestaurantScalarFieldEnum: {
    idRestaurant: 'idRestaurant',
    name: 'name',
    location: 'location',
    description: 'description'
  };

  export type RestaurantScalarFieldEnum = (typeof RestaurantScalarFieldEnum)[keyof typeof RestaurantScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    idCustomer?: IntFilter | number
    first_name?: StringFilter | string
    last_name?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
  }

  export type CustomerOrderByInput = {
    idCustomer?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type CustomerWhereUniqueInput = {
    idCustomer?: number
    email?: string
  }

  export type TableWhereInput = {
    AND?: Enumerable<TableWhereInput>
    OR?: Enumerable<TableWhereInput>
    NOT?: Enumerable<TableWhereInput>
    idTable?: IntFilter | number
    capacity?: IntFilter | number
    avalible?: BoolFilter | boolean
    restaurant?: XOR<RestaurantWhereInput, RestaurantRelationFilter>
    resutaurantId?: IntFilter | number
  }

  export type TableOrderByInput = {
    idTable?: SortOrder
    capacity?: SortOrder
    avalible?: SortOrder
    resutaurantId?: SortOrder
  }

  export type TableWhereUniqueInput = {
    idTable?: number
    resutaurantId?: number
  }

  export type RestaurantWhereInput = {
    AND?: Enumerable<RestaurantWhereInput>
    OR?: Enumerable<RestaurantWhereInput>
    NOT?: Enumerable<RestaurantWhereInput>
    idRestaurant?: IntFilter | number
    name?: StringFilter | string
    location?: StringFilter | string
    description?: StringFilter | string
    tables?: TableListRelationFilter
  }

  export type RestaurantOrderByInput = {
    idRestaurant?: SortOrder
    name?: SortOrder
    location?: SortOrder
    description?: SortOrder
  }

  export type RestaurantWhereUniqueInput = {
    idRestaurant?: number
  }

  export type CustomerCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
  }

  export type CustomerUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type TableCreateInput = {
    capacity: number
    avalible: boolean
    restaurant: RestaurantCreateOneWithoutTablesInput
  }

  export type TableUpdateInput = {
    capacity?: IntFieldUpdateOperationsInput | number
    avalible?: BoolFieldUpdateOperationsInput | boolean
    restaurant?: RestaurantUpdateOneRequiredWithoutTablesInput
  }

  export type TableUpdateManyMutationInput = {
    capacity?: IntFieldUpdateOperationsInput | number
    avalible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantCreateInput = {
    idRestaurant: number
    name: string
    location: string
    description: string
    tables?: TableCreateManyWithoutRestaurantInput
  }

  export type RestaurantUpdateInput = {
    idRestaurant?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tables?: TableUpdateManyWithoutRestaurantInput
  }

  export type RestaurantUpdateManyMutationInput = {
    idRestaurant?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type RestaurantRelationFilter = {
    is?: RestaurantWhereInput
    isNot?: RestaurantWhereInput
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type RestaurantCreateOneWithoutTablesInput = {
    create?: RestaurantCreateWithoutTablesInput
    connect?: RestaurantWhereUniqueInput
    connectOrCreate?: RestaurantCreateOrConnectWithouttablesInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type RestaurantUpdateOneRequiredWithoutTablesInput = {
    create?: RestaurantCreateWithoutTablesInput
    connect?: RestaurantWhereUniqueInput
    update?: RestaurantUpdateWithoutTablesInput
    upsert?: RestaurantUpsertWithoutTablesInput
    connectOrCreate?: RestaurantCreateOrConnectWithouttablesInput
  }

  export type TableCreateManyWithoutRestaurantInput = {
    create?: Enumerable<TableCreateWithoutRestaurantInput>
    connect?: Enumerable<TableWhereUniqueInput>
    connectOrCreate?: Enumerable<TableCreateOrConnectWithoutrestaurantInput>
  }

  export type TableUpdateManyWithoutRestaurantInput = {
    create?: Enumerable<TableCreateWithoutRestaurantInput>
    connect?: Enumerable<TableWhereUniqueInput>
    set?: Enumerable<TableWhereUniqueInput>
    disconnect?: Enumerable<TableWhereUniqueInput>
    delete?: Enumerable<TableWhereUniqueInput>
    update?: Enumerable<TableUpdateWithWhereUniqueWithoutRestaurantInput>
    updateMany?: Enumerable<TableUpdateManyWithWhereWithoutRestaurantInput>
    deleteMany?: Enumerable<TableScalarWhereInput>
    upsert?: Enumerable<TableUpsertWithWhereUniqueWithoutRestaurantInput>
    connectOrCreate?: Enumerable<TableCreateOrConnectWithoutrestaurantInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type RestaurantCreateWithoutTablesInput = {
    idRestaurant: number
    name: string
    location: string
    description: string
  }

  export type RestaurantCreateOrConnectWithouttablesInput = {
    where: RestaurantWhereUniqueInput
    create: RestaurantCreateWithoutTablesInput
  }

  export type RestaurantUpdateWithoutTablesInput = {
    idRestaurant?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RestaurantUpsertWithoutTablesInput = {
    update: RestaurantUpdateWithoutTablesInput
    create: RestaurantCreateWithoutTablesInput
  }

  export type TableCreateWithoutRestaurantInput = {
    capacity: number
    avalible: boolean
  }

  export type TableCreateOrConnectWithoutrestaurantInput = {
    where: TableWhereUniqueInput
    create: TableCreateWithoutRestaurantInput
  }

  export type TableUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: TableWhereUniqueInput
    data: TableUpdateWithoutRestaurantInput
  }

  export type TableUpdateManyWithWhereWithoutRestaurantInput = {
    where: TableScalarWhereInput
    data: TableUpdateManyMutationInput
  }

  export type TableScalarWhereInput = {
    AND?: Enumerable<TableScalarWhereInput>
    OR?: Enumerable<TableScalarWhereInput>
    NOT?: Enumerable<TableScalarWhereInput>
    idTable?: IntFilter | number
    capacity?: IntFilter | number
    avalible?: BoolFilter | boolean
    resutaurantId?: IntFilter | number
  }

  export type TableUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: TableWhereUniqueInput
    update: TableUpdateWithoutRestaurantInput
    create: TableCreateWithoutRestaurantInput
  }

  export type TableUpdateWithoutRestaurantInput = {
    capacity?: IntFieldUpdateOperationsInput | number
    avalible?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}

/*
* Exports for compatibility introduced in 2.12.0
* Please import from the Prisma namespace instead
*/

/**
 * @deprecated Renamed to `Prisma.CustomerScalarFieldEnum`
 */
export type CustomerScalarFieldEnum = Prisma.CustomerScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.TableScalarFieldEnum`
 */
export type TableScalarFieldEnum = Prisma.TableScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.RestaurantScalarFieldEnum`
 */
export type RestaurantScalarFieldEnum = Prisma.RestaurantScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.SortOrder`
 */
export type SortOrder = Prisma.SortOrder

/**
 * @deprecated Renamed to `Prisma.ModelName`
 */
export type ModelName = Prisma.ModelName

/**
 * @deprecated Renamed to `Prisma.AggregateCustomer`
 */
export type AggregateCustomer = Prisma.AggregateCustomer

/**
 * @deprecated Renamed to `Prisma.CustomerAvgAggregateOutputType`
 */
export type CustomerAvgAggregateOutputType = Prisma.CustomerAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CustomerSumAggregateOutputType`
 */
export type CustomerSumAggregateOutputType = Prisma.CustomerSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CustomerMinAggregateOutputType`
 */
export type CustomerMinAggregateOutputType = Prisma.CustomerMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CustomerMaxAggregateOutputType`
 */
export type CustomerMaxAggregateOutputType = Prisma.CustomerMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CustomerCountAggregateOutputType`
 */
export type CustomerCountAggregateOutputType = Prisma.CustomerCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateCustomerArgs`
 */
export type AggregateCustomerArgs = Prisma.AggregateCustomerArgs

/**
 * @deprecated Renamed to `Prisma.CustomerAvgAggregateInputType`
 */
export type CustomerAvgAggregateInputType = Prisma.CustomerAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CustomerSumAggregateInputType`
 */
export type CustomerSumAggregateInputType = Prisma.CustomerSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CustomerMinAggregateInputType`
 */
export type CustomerMinAggregateInputType = Prisma.CustomerMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CustomerMaxAggregateInputType`
 */
export type CustomerMaxAggregateInputType = Prisma.CustomerMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CustomerCountAggregateInputType`
 */
export type CustomerCountAggregateInputType = Prisma.CustomerCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CustomerSelect`
 */
export type CustomerSelect = Prisma.CustomerSelect

/**
 * @deprecated Renamed to `Prisma.FindUniqueCustomerArgs`
 */
export type FindUniqueCustomerArgs = Prisma.FindUniqueCustomerArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstCustomerArgs`
 */
export type FindFirstCustomerArgs = Prisma.FindFirstCustomerArgs

/**
 * @deprecated Renamed to `Prisma.FindManyCustomerArgs`
 */
export type FindManyCustomerArgs = Prisma.FindManyCustomerArgs

/**
 * @deprecated Renamed to `Prisma.CustomerCreateArgs`
 */
export type CustomerCreateArgs = Prisma.CustomerCreateArgs

/**
 * @deprecated Renamed to `Prisma.CustomerUpdateArgs`
 */
export type CustomerUpdateArgs = Prisma.CustomerUpdateArgs

/**
 * @deprecated Renamed to `Prisma.CustomerUpdateManyArgs`
 */
export type CustomerUpdateManyArgs = Prisma.CustomerUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.CustomerUpsertArgs`
 */
export type CustomerUpsertArgs = Prisma.CustomerUpsertArgs

/**
 * @deprecated Renamed to `Prisma.CustomerDeleteArgs`
 */
export type CustomerDeleteArgs = Prisma.CustomerDeleteArgs

/**
 * @deprecated Renamed to `Prisma.CustomerDeleteManyArgs`
 */
export type CustomerDeleteManyArgs = Prisma.CustomerDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateTable`
 */
export type AggregateTable = Prisma.AggregateTable

/**
 * @deprecated Renamed to `Prisma.TableAvgAggregateOutputType`
 */
export type TableAvgAggregateOutputType = Prisma.TableAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.TableSumAggregateOutputType`
 */
export type TableSumAggregateOutputType = Prisma.TableSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.TableMinAggregateOutputType`
 */
export type TableMinAggregateOutputType = Prisma.TableMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.TableMaxAggregateOutputType`
 */
export type TableMaxAggregateOutputType = Prisma.TableMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.TableCountAggregateOutputType`
 */
export type TableCountAggregateOutputType = Prisma.TableCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateTableArgs`
 */
export type AggregateTableArgs = Prisma.AggregateTableArgs

/**
 * @deprecated Renamed to `Prisma.TableAvgAggregateInputType`
 */
export type TableAvgAggregateInputType = Prisma.TableAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.TableSumAggregateInputType`
 */
export type TableSumAggregateInputType = Prisma.TableSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.TableMinAggregateInputType`
 */
export type TableMinAggregateInputType = Prisma.TableMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.TableMaxAggregateInputType`
 */
export type TableMaxAggregateInputType = Prisma.TableMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.TableCountAggregateInputType`
 */
export type TableCountAggregateInputType = Prisma.TableCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.TableSelect`
 */
export type TableSelect = Prisma.TableSelect

/**
 * @deprecated Renamed to `Prisma.TableInclude`
 */
export type TableInclude = Prisma.TableInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueTableArgs`
 */
export type FindUniqueTableArgs = Prisma.FindUniqueTableArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstTableArgs`
 */
export type FindFirstTableArgs = Prisma.FindFirstTableArgs

/**
 * @deprecated Renamed to `Prisma.FindManyTableArgs`
 */
export type FindManyTableArgs = Prisma.FindManyTableArgs

/**
 * @deprecated Renamed to `Prisma.TableCreateArgs`
 */
export type TableCreateArgs = Prisma.TableCreateArgs

/**
 * @deprecated Renamed to `Prisma.TableUpdateArgs`
 */
export type TableUpdateArgs = Prisma.TableUpdateArgs

/**
 * @deprecated Renamed to `Prisma.TableUpdateManyArgs`
 */
export type TableUpdateManyArgs = Prisma.TableUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.TableUpsertArgs`
 */
export type TableUpsertArgs = Prisma.TableUpsertArgs

/**
 * @deprecated Renamed to `Prisma.TableDeleteArgs`
 */
export type TableDeleteArgs = Prisma.TableDeleteArgs

/**
 * @deprecated Renamed to `Prisma.TableDeleteManyArgs`
 */
export type TableDeleteManyArgs = Prisma.TableDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateRestaurant`
 */
export type AggregateRestaurant = Prisma.AggregateRestaurant

/**
 * @deprecated Renamed to `Prisma.RestaurantAvgAggregateOutputType`
 */
export type RestaurantAvgAggregateOutputType = Prisma.RestaurantAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.RestaurantSumAggregateOutputType`
 */
export type RestaurantSumAggregateOutputType = Prisma.RestaurantSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.RestaurantMinAggregateOutputType`
 */
export type RestaurantMinAggregateOutputType = Prisma.RestaurantMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.RestaurantMaxAggregateOutputType`
 */
export type RestaurantMaxAggregateOutputType = Prisma.RestaurantMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.RestaurantCountAggregateOutputType`
 */
export type RestaurantCountAggregateOutputType = Prisma.RestaurantCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateRestaurantArgs`
 */
export type AggregateRestaurantArgs = Prisma.AggregateRestaurantArgs

/**
 * @deprecated Renamed to `Prisma.RestaurantAvgAggregateInputType`
 */
export type RestaurantAvgAggregateInputType = Prisma.RestaurantAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.RestaurantSumAggregateInputType`
 */
export type RestaurantSumAggregateInputType = Prisma.RestaurantSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.RestaurantMinAggregateInputType`
 */
export type RestaurantMinAggregateInputType = Prisma.RestaurantMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.RestaurantMaxAggregateInputType`
 */
export type RestaurantMaxAggregateInputType = Prisma.RestaurantMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.RestaurantCountAggregateInputType`
 */
export type RestaurantCountAggregateInputType = Prisma.RestaurantCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.RestaurantSelect`
 */
export type RestaurantSelect = Prisma.RestaurantSelect

/**
 * @deprecated Renamed to `Prisma.RestaurantInclude`
 */
export type RestaurantInclude = Prisma.RestaurantInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueRestaurantArgs`
 */
export type FindUniqueRestaurantArgs = Prisma.FindUniqueRestaurantArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstRestaurantArgs`
 */
export type FindFirstRestaurantArgs = Prisma.FindFirstRestaurantArgs

/**
 * @deprecated Renamed to `Prisma.FindManyRestaurantArgs`
 */
export type FindManyRestaurantArgs = Prisma.FindManyRestaurantArgs

/**
 * @deprecated Renamed to `Prisma.RestaurantCreateArgs`
 */
export type RestaurantCreateArgs = Prisma.RestaurantCreateArgs

/**
 * @deprecated Renamed to `Prisma.RestaurantUpdateArgs`
 */
export type RestaurantUpdateArgs = Prisma.RestaurantUpdateArgs

/**
 * @deprecated Renamed to `Prisma.RestaurantUpdateManyArgs`
 */
export type RestaurantUpdateManyArgs = Prisma.RestaurantUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.RestaurantUpsertArgs`
 */
export type RestaurantUpsertArgs = Prisma.RestaurantUpsertArgs

/**
 * @deprecated Renamed to `Prisma.RestaurantDeleteArgs`
 */
export type RestaurantDeleteArgs = Prisma.RestaurantDeleteArgs

/**
 * @deprecated Renamed to `Prisma.RestaurantDeleteManyArgs`
 */
export type RestaurantDeleteManyArgs = Prisma.RestaurantDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.CustomerWhereInput`
 */
export type CustomerWhereInput = Prisma.CustomerWhereInput

/**
 * @deprecated Renamed to `Prisma.CustomerOrderByInput`
 */
export type CustomerOrderByInput = Prisma.CustomerOrderByInput

/**
 * @deprecated Renamed to `Prisma.CustomerWhereUniqueInput`
 */
export type CustomerWhereUniqueInput = Prisma.CustomerWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.TableWhereInput`
 */
export type TableWhereInput = Prisma.TableWhereInput

/**
 * @deprecated Renamed to `Prisma.TableOrderByInput`
 */
export type TableOrderByInput = Prisma.TableOrderByInput

/**
 * @deprecated Renamed to `Prisma.TableWhereUniqueInput`
 */
export type TableWhereUniqueInput = Prisma.TableWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.RestaurantWhereInput`
 */
export type RestaurantWhereInput = Prisma.RestaurantWhereInput

/**
 * @deprecated Renamed to `Prisma.RestaurantOrderByInput`
 */
export type RestaurantOrderByInput = Prisma.RestaurantOrderByInput

/**
 * @deprecated Renamed to `Prisma.RestaurantWhereUniqueInput`
 */
export type RestaurantWhereUniqueInput = Prisma.RestaurantWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.CustomerCreateInput`
 */
export type CustomerCreateInput = Prisma.CustomerCreateInput

/**
 * @deprecated Renamed to `Prisma.CustomerUpdateInput`
 */
export type CustomerUpdateInput = Prisma.CustomerUpdateInput

/**
 * @deprecated Renamed to `Prisma.CustomerUpdateManyMutationInput`
 */
export type CustomerUpdateManyMutationInput = Prisma.CustomerUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.TableCreateInput`
 */
export type TableCreateInput = Prisma.TableCreateInput

/**
 * @deprecated Renamed to `Prisma.TableUpdateInput`
 */
export type TableUpdateInput = Prisma.TableUpdateInput

/**
 * @deprecated Renamed to `Prisma.TableUpdateManyMutationInput`
 */
export type TableUpdateManyMutationInput = Prisma.TableUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.RestaurantCreateInput`
 */
export type RestaurantCreateInput = Prisma.RestaurantCreateInput

/**
 * @deprecated Renamed to `Prisma.RestaurantUpdateInput`
 */
export type RestaurantUpdateInput = Prisma.RestaurantUpdateInput

/**
 * @deprecated Renamed to `Prisma.RestaurantUpdateManyMutationInput`
 */
export type RestaurantUpdateManyMutationInput = Prisma.RestaurantUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.IntFilter`
 */
export type IntFilter = Prisma.IntFilter

/**
 * @deprecated Renamed to `Prisma.StringFilter`
 */
export type StringFilter = Prisma.StringFilter

/**
 * @deprecated Renamed to `Prisma.BoolFilter`
 */
export type BoolFilter = Prisma.BoolFilter

/**
 * @deprecated Renamed to `Prisma.RestaurantRelationFilter`
 */
export type RestaurantRelationFilter = Prisma.RestaurantRelationFilter

/**
 * @deprecated Renamed to `Prisma.TableListRelationFilter`
 */
export type TableListRelationFilter = Prisma.TableListRelationFilter

/**
 * @deprecated Renamed to `Prisma.StringFieldUpdateOperationsInput`
 */
export type StringFieldUpdateOperationsInput = Prisma.StringFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.RestaurantCreateOneWithoutTablesInput`
 */
export type RestaurantCreateOneWithoutTablesInput = Prisma.RestaurantCreateOneWithoutTablesInput

/**
 * @deprecated Renamed to `Prisma.IntFieldUpdateOperationsInput`
 */
export type IntFieldUpdateOperationsInput = Prisma.IntFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.BoolFieldUpdateOperationsInput`
 */
export type BoolFieldUpdateOperationsInput = Prisma.BoolFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.RestaurantUpdateOneRequiredWithoutTablesInput`
 */
export type RestaurantUpdateOneRequiredWithoutTablesInput = Prisma.RestaurantUpdateOneRequiredWithoutTablesInput

/**
 * @deprecated Renamed to `Prisma.TableCreateManyWithoutRestaurantInput`
 */
export type TableCreateManyWithoutRestaurantInput = Prisma.TableCreateManyWithoutRestaurantInput

/**
 * @deprecated Renamed to `Prisma.TableUpdateManyWithoutRestaurantInput`
 */
export type TableUpdateManyWithoutRestaurantInput = Prisma.TableUpdateManyWithoutRestaurantInput

/**
 * @deprecated Renamed to `Prisma.NestedIntFilter`
 */
export type NestedIntFilter = Prisma.NestedIntFilter

/**
 * @deprecated Renamed to `Prisma.NestedStringFilter`
 */
export type NestedStringFilter = Prisma.NestedStringFilter

/**
 * @deprecated Renamed to `Prisma.NestedBoolFilter`
 */
export type NestedBoolFilter = Prisma.NestedBoolFilter

/**
 * @deprecated Renamed to `Prisma.RestaurantCreateWithoutTablesInput`
 */
export type RestaurantCreateWithoutTablesInput = Prisma.RestaurantCreateWithoutTablesInput

/**
 * @deprecated Renamed to `Prisma.RestaurantCreateOrConnectWithouttablesInput`
 */
export type RestaurantCreateOrConnectWithouttablesInput = Prisma.RestaurantCreateOrConnectWithouttablesInput

/**
 * @deprecated Renamed to `Prisma.RestaurantUpdateWithoutTablesInput`
 */
export type RestaurantUpdateWithoutTablesInput = Prisma.RestaurantUpdateWithoutTablesInput

/**
 * @deprecated Renamed to `Prisma.RestaurantUpsertWithoutTablesInput`
 */
export type RestaurantUpsertWithoutTablesInput = Prisma.RestaurantUpsertWithoutTablesInput

/**
 * @deprecated Renamed to `Prisma.TableCreateWithoutRestaurantInput`
 */
export type TableCreateWithoutRestaurantInput = Prisma.TableCreateWithoutRestaurantInput

/**
 * @deprecated Renamed to `Prisma.TableCreateOrConnectWithoutrestaurantInput`
 */
export type TableCreateOrConnectWithoutrestaurantInput = Prisma.TableCreateOrConnectWithoutrestaurantInput

/**
 * @deprecated Renamed to `Prisma.TableUpdateWithWhereUniqueWithoutRestaurantInput`
 */
export type TableUpdateWithWhereUniqueWithoutRestaurantInput = Prisma.TableUpdateWithWhereUniqueWithoutRestaurantInput

/**
 * @deprecated Renamed to `Prisma.TableUpdateManyWithWhereWithoutRestaurantInput`
 */
export type TableUpdateManyWithWhereWithoutRestaurantInput = Prisma.TableUpdateManyWithWhereWithoutRestaurantInput

/**
 * @deprecated Renamed to `Prisma.TableScalarWhereInput`
 */
export type TableScalarWhereInput = Prisma.TableScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.TableUpsertWithWhereUniqueWithoutRestaurantInput`
 */
export type TableUpsertWithWhereUniqueWithoutRestaurantInput = Prisma.TableUpsertWithWhereUniqueWithoutRestaurantInput

/**
 * @deprecated Renamed to `Prisma.TableUpdateWithoutRestaurantInput`
 */
export type TableUpdateWithoutRestaurantInput = Prisma.TableUpdateWithoutRestaurantInput